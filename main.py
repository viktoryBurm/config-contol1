# Импорт необходимых модулей Python
import os  # для работы с операционной системой (файлы, директории, пути)
import shlex  # для корректного разбиения командной строки с учетом кавычек
import socket  # для получения информации о сетевых параметрах (имя хоста)
import argparse  # для парсинга аргументов командной строки
import sys  # для работы с системными параметрами (не используется явно, но может потребоваться)

class ShellEmulator:
    """
    Основной класс эмулятора командной строки.
    Реализует функциональность REPL (Read-Eval-Print Loop) цикла.
    """
    
    def __init__(self, vfs_path=None, startup_script=None):
        """
        Конструктор класса. Инициализирует эмулятор.
        
        Args:
            vfs_path (str, optional): Путь к виртуальной файловой системе
            startup_script (str, optional): Путь к стартовому скрипту для автоматического выполнения
        """
        
        # Получаем имя текущего пользователя ОС для отображения в приглашении
        self.username = os.getlogin()
        
        # Получаем сетевое имя компьютера для отображения в приглашении
        self.hostname = socket.gethostname()
        
        # Получаем текущую рабочую директорию для отображения в приглашении
        self.current_dir = os.getcwd()
        
        # Флаг работы эмулятора. Когда становится False - программа завершается
        self.running = True
        
        # Сохраняем путь к виртуальной файловой системе (Virtual File System)
        # Если параметр не передан, будет использоваться None
        self.vfs_path = vfs_path
        
        # Сохраняем путь к стартовому скрипту
        # Если параметр не передан, будет использоваться None
        self.startup_script = startup_script
        
        # Выводим отладочную информацию о конфигурации эмулятора
        print("КОНФИГУРАЦИЯ ЭМУЛЯТОРА")
        # Выводим путь к VFS или сообщение, что путь не указан
        print(f"VFS путь: {self.vfs_path or 'Не указан'}")
        # Выводим путь к стартовому скрипту или сообщение, что скрипт не указан
        print(f"Стартовый скрипт: {self.startup_script or 'Не указан'}")
        # Рисуем разделительную линию для визуального отделения конфигурации
        print("=" * 40)
    
    def get_prompt(self):
        """
        Формирует строку приглашения к вводу в формате username@hostname:directory$
        
        Returns:
            str: Строка приглашения для пользователя
        """
        
        # Проверяем, находимся ли мы в домашней директории пользователя
        if self.current_dir != os.path.expanduser("~"):
            # Если нет - берем только имя текущей директории (без полного пути)
            dir_name = os.path.basename(self.current_dir)
        else:
            # Если да - используем символ '~' как в настоящем bash
            dir_name = "~"
        
        # Формируем и возвращаем строку приглашения
        return f"{self.username}@{self.hostname}:{dir_name}$ "
    
    def parse_command(self, command_line):
        """
        Разбивает строку команды на имя команды и аргументы с учетом кавычек.
        
        Args:
            command_line (str): Строка, введенная пользователем
            
        Returns:
            tuple: (command, args) где command - имя команды, args - список аргументов
                   или (None, []) если строка пустая или произошла ошибка парсинга
        """
        
        try:
            # Используем shlex.split для корректного разбиения строки
            # Этот метод правильно обрабатывает кавычки и экранирование
            parts = shlex.split(command_line)
            
            # Если после разбиения получили пустой список (пользователь ввел пустую строку)
            if not parts:
                return None, []  # Возвращаем None и пустой список аргументов
            
            # Первый элемент - это имя команды
            command = parts[0]
            # Все остальные элементы - это аргументы команды
            args = parts[1:]
            
            return command, args
            
        except ValueError as e:
            # Обрабатываем ошибки парсинга (например, незакрытые кавычки)
            print(f"Ошибка парсинга: {e}")
            return None, []  # Возвращаем None и пустой список при ошибке
    
    def execute_command(self, command, args):
        """
        Выполняет команду эмулятора.
        
        Args:
            command (str): Имя команды для выполнения
            args (list): Список аргументов команды
        """
        
        # Проверяем команду exit - завершение работы эмулятора
        if command == "exit":
            # Устанавливаем флаг работы в False для остановки основного цикла
            self.running = False
            print("Выход из эмулятора")
        
        # Обрабатываем команду ls (list directory)
        elif command == "ls":
            print(f"Команда: ls")  # Выводим имя команды
            
            # Проверяем есть ли аргументы у команды
            if args:
                print(f"Аргументы: {args}")  # Выводим аргументы если они есть
            else:
                print("Аргументы отсутствуют")  # Сообщаем об отсутствии аргументов
        
        # Обрабатываем команду cd (change directory)
        elif command == "cd":
            print(f"Команда: cd")  # Выводим имя команды
            
            # Проверяем есть ли аргументы у команды
            if args:
                print(f"Аргументы: {args}")  # Выводим аргументы если они есть
                # В реальной реализации здесь будет логика смены директории
                # self.current_dir = args[0] и проверка существования пути
            else:
                print("Аргументы отсутствуют")  # Сообщаем об отсутствии аргументов
        
        # Добавляем команду echo для демонстрации работы с аргументами
        elif command == "echo":
            # Просто выводим все аргументы, объединенные в строку
            print(f"echo: {' '.join(args)}")
        
        # Обрабатываем неизвестные команды
        elif command:
            print(f"Команда '{command}' не найдена")
    
    def run_script(self, script_path):
        """
        Выполняет команды из файла скрипта.
        
        Args:
            script_path (str): Путь к файлу скрипта
        """
        
        # Проверяем существует ли файл скрипта
        if not os.path.exists(script_path):
            print(f"Ошибка: скрипт '{script_path}' не найден")
            return  # Выходим из функции если файл не существует
        
        # Сообщаем о начале выполнения скрипта
        print(f"\nВЫПОЛНЕНИЕ СКРИПТА: {script_path}")
        
        try:
            # Открываем файл скрипта для чтения с кодировкой UTF-8
            with open(script_path, 'r', encoding='utf-8') as file:
                # Читаем все строки файла в список
                lines = file.readlines()
            
            # Проходим по всем строкам скрипта, нумеруя их начиная с 1
            for line_num, line in enumerate(lines, 1):
                # Убираем пробельные символы в начале и конце строки
                line = line.strip()
                
                # Пропускаем пустые строки и строки-комментарии (начинающиеся с #)
                if not line or line.startswith('#'):
                    continue  # Переходим к следующей строке
                
                # Имитируем интерактивный ввод: показываем приглашение и команду
                prompt = self.get_prompt()  # Получаем текущее приглашение
                print(f"{prompt}{line}")  # Выводим как будто пользователь ввел эту команду
                
                # Парсим команду из строки скрипта
                command, args = self.parse_command(line)
                
                # Если команда распаршена успешно - выполняем ее
                if command:
                    self.execute_command(command, args)
                else:
                    # Если произошла ошибка парсинга - сообщаем и пропускаем строку
                    print(f"Строка {line_num}: ошибка парсинга - пропускаем")
                
                # Печатаем пустую строку для визуального разделения команд
                print()
            
            # Сообщаем о завершении выполнения скрипта
            print("ВЫПОЛНЕНИЕ СКРИПТА ЗАВЕРШЕНО")
            
        except Exception as e:
            # Обрабатываем любые исключения при работе с файлом скрипта
            print(f"Ошибка при выполнении скрипта: {e}")
    
    def run(self):
        """
        Основной метод запуска эмулятора.
        Реализует главный цикл программы.
        """
        
        # Сначала выполняем стартовый скрипт, если он был указан
        if self.startup_script:
            self.run_script(self.startup_script)
        
        # Затем переходим в интерактивный режим работы с пользователем
        print("\nИНТЕРАКТИВНЫЙ РЕЖИМ")
        print("Доступные команды: ls, cd, echo, exit")  # Список поддерживаемых команд
        print("Для выхода введите 'exit'")  # Подсказка как выйти
        print("-" * 50)  # Разделительная линия
        
        # Главный цикл программы - работает пока self.running = True
        while self.running:
            try:
                # Получаем текущее приглашение для ввода
                prompt = self.get_prompt()
                # Ждем ввода от пользователя и убираем пробелы по краям
                user_input = input(prompt).strip()
                
                # Если пользователь ввел пустую строку - пропускаем итерацию
                if not user_input:
                    continue  # Переходим к следующей итерации цикла
                
                # Парсим введенную команду на имя и аргументы
                command, args = self.parse_command(user_input)
                
                # Если команда успешно распарсена - выполняем ее
                if command:
                    self.execute_command(command, args)
                else:
                    # Если не удалось разобрать команду - сообщаем об ошибке
                    print("Ошибка: не удалось разобрать команду")
                    
            except KeyboardInterrupt:
                # Обрабатываем нажатие Ctrl+C - не выходим, а только сообщаем
                print("\nДля выхода используйте команду 'exit'")
            except EOFError:
                # Обрабатываем нажатие Ctrl+D (конец файла) - выходим из цикла
                print("\nВыход из эмулятора")
                break  # Прерываем цикл

def parse_arguments():
    """
    Парсит аргументы командной строки при запуске программы.
    
    Returns:
        argparse.Namespace: Объект с распарсенными аргументами
    """
    
    # Создаем парсер аргументов с описанием программы
    parser = argparse.ArgumentParser(description='Эмулятор командной строки UNIX')
    
    # Добавляем аргумент для пути к VFS
    # --vfs-path - имя аргумента в командной строке
    # help - текст справки который покажется при --help
    # default=None - значение по умолчанию если аргумент не указан
    parser.add_argument('--vfs-path', 
                       help='Путь к физическому расположению VFS',
                       default=None)
    
    # Добавляем аргумент для пути к стартовому скрипту
    parser.add_argument('--startup-script',
                       help='Путь к стартовому скрипту',
                       default=None)
    
    # Парсим аргументы командной строки и возвращаем результат
    return parser.parse_args()

def create_test_scripts():
    """
    Создает тестовые скрипты для демонстрации работы эмулятора.
    Скрипты создаются в текущей рабочей директории.
    """
    
    # Словарь с именами файлов и их содержимым
    scripts = {
        # Скрипт для тестирования базовых команд
        'test_basic.sh': '''#!/bin/bash
# Тестовый скрипт для базовых команд
echo "Начало выполнения скрипта"
ls
cd /home/user
echo "Аргументы в кавычках" "работают правильно"
ls -la
echo "Конец скрипта"
''',
        
        # Скрипт для тестирования обработки ошибок
        'test_errors.sh': '''#!/bin/bash
# Скрипт с ошибками для тестирования обработки
echo "Сначала корректная команда"
unknown_command_that_should_fail
echo "Эта команда выполнится после ошибки"
cd "незакрытая кавычка
echo "Этот echo не выполнится из-за ошибки выше"
''',
        
        # Скрипт для тестирования параметров командной строки
        'test_params.sh': '''#!/bin/bash
# Скрипт для тестирования параметров эмулятора
echo "VFS путь: должен быть передан через --vfs-path"
echo "Этот скрипт: должен быть передан через --startup-script"
ls
echo "Тестирование завершено"
'''
    }
    
    # Проходим по всем скриптам из словаря
    for filename, content in scripts.items():
        # Открываем файл для записи с кодировкой UTF-8
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(content)  # Записываем содержимое в файл
        
        # На Unix-системах делаем скрипты исполняемыми
        if os.name != 'nt':  # Проверяем что это не Windows
            os.chmod(filename, 0o755)  # Устанавливаем права на выполнение
        
        # Сообщаем о создании файла
        print(f"Создан тестовый скрипт: {filename}")
    

def main():
    """
    Главная функция программы - точка входа.
    Координирует весь процесс работы эмулятора.
    """
    
    # Парсим аргументы командной строки
    args = parse_arguments()
    
    
    # Создаем экземпляр эмулятора с переданными параметрами
    shell = ShellEmulator(
        vfs_path=args.vfs_path,  # Путь к VFS из аргументов
        startup_script=args.startup_script  # Путь к скрипту из аргументов
    )
    
    # Запускаем основной цикл эмулятора
    shell.run()

# Стандартная конструкция для точки входа в Python программу
if __name__ == "__main__":
    main()  # Вызываем главную функцию при прямом запуске файла